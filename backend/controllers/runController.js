const { spawn } = require("child_process");
const { randomUUID } = require("crypto");
const fs = require("fs");
const os = require("os");
const path = require("path");
const Project = require("../models/Project");
const { findNode } = require("../utils/tree");

const MAX_OUTPUT_BYTES = 1024 * 1024;
const LEGACY_TIMEOUT_MS = 5000;
const DEFAULT_SESSION_TIMEOUT_MS = 10 * 60 * 1000;
const MIN_SESSION_TIMEOUT_MS = 30 * 1000;
const SESSION_TIMEOUT_MS = (() => {
  const raw = Number(process.env.RUN_SESSION_TIMEOUT_MS);
  if (!Number.isFinite(raw) || raw <= 0) return DEFAULT_SESSION_TIMEOUT_MS;
  return Math.max(raw, MIN_SESSION_TIMEOUT_MS);
})();
const SESSION_TTL_MS = 30000;
const runSessions = new Map();

const invalidInputError = (message) => {
  const err = new Error(message);
  err.status = 400;
  return err;
};

const isValidPathSegment = (segment) =>
  typeof segment === "string" &&
  segment.length > 0 &&
  segment !== "." &&
  segment !== ".." &&
  !/[\\/]/.test(segment) &&
  !segment.includes("\0");

const normalizeRelativePath = (value) => {
  if (typeof value !== "string") return null;
  const normalized = value.replace(/\\/g, "/");
  const segments = normalized.split("/").filter(Boolean);
  if (!segments.length) return null;
  if (!segments.every(isValidPathSegment)) return null;
  return segments.join("/");
};

const normalizeWorkspaceFiles = (files) => {
  if (!Array.isArray(files) || !files.length) return [];

  const seen = new Set();
  return files.map((file) => {
    if (!file || typeof file !== "object") {
      throw invalidInputError("Workspace files must be objects.");
    }

    const relativePath = normalizeRelativePath(file.path);
    if (!relativePath) {
      throw invalidInputError("Workspace file paths are invalid.");
    }

    if (seen.has(relativePath)) {
      throw invalidInputError(`Duplicate workspace file path: ${relativePath}`);
    }
    seen.add(relativePath);

    return {
      path: relativePath,
      content: typeof file.content === "string" ? file.content : "",
    };
  });
};

const flattenProjectWorkspace = (
  nodes,
  parentSegments = [],
  files = [],
  idToPath = new Map(),
  seenPaths = new Set()
) => {
  for (const node of nodes || []) {
    const rawName = typeof node?.name === "string" ? node.name.trim() : "";
    if (!isValidPathSegment(rawName)) {
      throw invalidInputError("Project contains invalid file or folder names.");
    }

    const nextSegments = [...parentSegments, rawName];

    if (node.type === "folder") {
      flattenProjectWorkspace(node.children || [], nextSegments, files, idToPath, seenPaths);
      continue;
    }

    if (node.type !== "file") continue;

    const relativePath = nextSegments.join("/");
    if (seenPaths.has(relativePath)) {
      throw invalidInputError(`Duplicate project file path: ${relativePath}`);
    }
    seenPaths.add(relativePath);

    files.push({
      path: relativePath,
      content: typeof node.content === "string" ? node.content : "",
    });
    if (typeof node.id === "string") {
      idToPath.set(node.id, relativePath);
    }
  }

  return { files, idToPath };
};

const resolveExecutionContext = async ({
  code,
  projectId,
  fileId,
  files,
  entryFile,
  userId,
}) => {
  let source = code;
  let workspaceFiles = normalizeWorkspaceFiles(files);
  let entryRelativePath = null;

  if (workspaceFiles.length) {
    entryRelativePath = normalizeRelativePath(entryFile) || workspaceFiles[0].path;
    const workspacePaths = new Set(workspaceFiles.map((file) => file.path));
    if (!workspacePaths.has(entryRelativePath)) {
      throw invalidInputError("Entry file is missing from workspace files.");
    }

    if (typeof source !== "string") {
      source =
        workspaceFiles.find((file) => file.path === entryRelativePath)?.content || "";
    }
  } else if (!source && projectId && fileId) {
    const project = await Project.findOne({ _id: projectId, userId });
    if (!project) {
      const err = new Error("Project not found");
      err.status = 404;
      throw err;
    }

    const node = findNode(project.files, fileId);
    if (!node || node.type !== "file") {
      const err = new Error("File not found");
      err.status = 404;
      throw err;
    }

    source = node.content || "";
    const flattened = flattenProjectWorkspace(project.files || []);
    workspaceFiles = flattened.files;
    entryRelativePath = flattened.idToPath.get(fileId) || null;
  }

  if (typeof source !== "string") {
    throw invalidInputError("Code required");
  }

  return {
    source,
    workspaceFiles,
    entryRelativePath,
  };
};

const writeTempFile = (source) => {
  const tempFile = path.join(
    os.tmpdir(),
    `codelearn-${Date.now()}-${Math.random().toString(16).slice(2)}.py`
  );
  fs.writeFileSync(tempFile, source, "utf8");
  return tempFile;
};

const createTempWorkspace = (workspaceFiles, entryRelativePath) => {
  const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "codelearn-"));

  try {
    for (const file of workspaceFiles) {
      const absolutePath = path.resolve(tempDir, ...file.path.split("/"));
      if (!absolutePath.startsWith(`${path.resolve(tempDir)}${path.sep}`)) {
        throw invalidInputError("Invalid workspace file path.");
      }
      fs.mkdirSync(path.dirname(absolutePath), { recursive: true });
      fs.writeFileSync(absolutePath, file.content, "utf8");
    }

    const selectedEntry = entryRelativePath || workspaceFiles[0]?.path;
    const entryPath = normalizeRelativePath(selectedEntry);
    if (!entryPath) {
      throw invalidInputError("Entry file is invalid.");
    }

    const tempFile = path.resolve(tempDir, ...entryPath.split("/"));
    if (!tempFile.startsWith(`${path.resolve(tempDir)}${path.sep}`) || !fs.existsSync(tempFile)) {
      throw invalidInputError("Entry file not found in workspace.");
    }

    return { tempFile, tempDir };
  } catch (err) {
    fs.rmSync(tempDir, { recursive: true, force: true });
    throw err;
  }
};

const createExecutionTarget = ({ source, workspaceFiles, entryRelativePath }) => {
  if (workspaceFiles.length) {
    return createTempWorkspace(workspaceFiles, entryRelativePath);
  }
  return { tempFile: writeTempFile(source), tempDir: null };
};

const cleanupTempArtifacts = ({ tempFile, tempDir }) => {
  if (tempDir) {
    fs.rm(tempDir, { recursive: true, force: true }, () => {});
    return;
  }
  if (tempFile) {
    fs.unlink(tempFile, () => {});
  }
};

const sendSse = (res, event, data) => {
  res.write(`event: ${event}\n`);
  res.write(`data: ${JSON.stringify(data)}\n\n`);
};

const emitSessionEvent = (session, event, data) => {
  session.events.push({ event, data });
  for (const client of session.clients) {
    try {
      sendSse(client, event, data);
    } catch {
      session.clients.delete(client);
    }
  }
};

const cleanupSession = (session) => {
  for (const client of session.clients) {
    if (!client.writableEnded) {
      client.end();
    }
  }
  session.clients.clear();
  runSessions.delete(session.id);
};

const finishSession = (session, payload) => {
  if (session.finished) return;
  session.finished = true;
  clearTimeout(session.killTimer);
  if (session.cleanupTimer) clearTimeout(session.cleanupTimer);
  cleanupTempArtifacts({ tempFile: session.tempFile, tempDir: session.tempDir });

  emitSessionEvent(session, "end", payload);

  for (const client of session.clients) {
    if (!client.writableEnded) {
      client.end();
    }
  }
  session.clients.clear();

  session.cleanupTimer = setTimeout(() => {
    cleanupSession(session);
  }, SESSION_TTL_MS);
};

const runPython = async (req, res) => {
  let tempFile = null;
  let tempDir = null;

  try {
    const { code, projectId, fileId, input, files, entryFile } = req.body;
    const context = await resolveExecutionContext({
      code,
      projectId,
      fileId,
      files,
      entryFile,
      userId: req.user.id,
    });
    const target = createExecutionTarget(context);
    tempFile = target.tempFile;
    tempDir = target.tempDir;

    const child = spawn("python", ["-u", tempFile], {
      stdio: ["pipe", "pipe", "pipe"],
      cwd: tempDir || path.dirname(tempFile),
    });

    let stdout = "";
    let stderr = "";
    let killed = false;
    let completed = false;

    const killTimer = setTimeout(() => {
      killed = true;
      child.kill("SIGKILL");
    }, LEGACY_TIMEOUT_MS);

    const finish = (output) => {
      if (completed) return null;
      completed = true;
      clearTimeout(killTimer);
      cleanupTempArtifacts({ tempFile, tempDir });
      return res.json({ output });
    };

    child.stdout.on("data", (chunk) => {
      stdout += chunk.toString();
      if (stdout.length > MAX_OUTPUT_BYTES) {
        killed = true;
        child.kill("SIGKILL");
      }
    });

    child.stderr.on("data", (chunk) => {
      stderr += chunk.toString();
      if (stderr.length > MAX_OUTPUT_BYTES) {
        killed = true;
        child.kill("SIGKILL");
      }
    });

    child.on("error", (err) => {
      return finish(err.message);
    });

    child.on("close", () => {
      if (killed) {
        return finish("Execution timed out or output was too large.");
      }
      return finish(stderr || stdout);
    });

    if (typeof input === "string" && input.length) {
      child.stdin.write(input);
    }
    child.stdin.end();
  } catch (err) {
    cleanupTempArtifacts({ tempFile, tempDir });
    return res.status(err.status || 500).json({ error: err.message || "Run failed" });
  }
};

const startRunSession = async (req, res) => {
  let tempFile = null;
  let tempDir = null;

  try {
    const { code, projectId, fileId, input, files, entryFile } = req.body;
    const context = await resolveExecutionContext({
      code,
      projectId,
      fileId,
      files,
      entryFile,
      userId: req.user.id,
    });
    const target = createExecutionTarget(context);
    tempFile = target.tempFile;
    tempDir = target.tempDir;

    const child = spawn("python", ["-u", tempFile], {
      stdio: ["pipe", "pipe", "pipe"],
      cwd: tempDir || path.dirname(tempFile),
    });
    const sessionId = randomUUID();

    const session = {
      id: sessionId,
      userId: req.user.id,
      child,
      tempFile,
      tempDir,
      clients: new Set(),
      events: [],
      outputBytes: 0,
      finished: false,
      terminatedReason: "",
      killTimer: null,
      cleanupTimer: null,
    };

    runSessions.set(sessionId, session);

    emitSessionEvent(session, "session", {
      sessionId,
      status: "running",
      timeoutMs: SESSION_TIMEOUT_MS,
    });

    const handleOutput = (stream, chunk) => {
      if (session.finished) return;
      session.outputBytes += Buffer.byteLength(chunk);
      if (session.outputBytes > MAX_OUTPUT_BYTES) {
        session.terminatedReason = "Execution output was too large.";
        child.kill("SIGKILL");
        return;
      }
      emitSessionEvent(session, "output", { stream, chunk: chunk.toString() });
    };

    child.stdout.on("data", (chunk) => handleOutput("stdout", chunk));
    child.stderr.on("data", (chunk) => handleOutput("stderr", chunk));

    child.on("error", (err) => {
      finishSession(session, { status: "error", message: err.message });
    });

    child.on("close", (exitCode, signal) => {
      if (session.finished) return;
      if (session.terminatedReason) {
        finishSession(session, { status: "killed", message: session.terminatedReason });
        return;
      }
      if (exitCode === 0) {
        finishSession(session, { status: "ok", exitCode: 0 });
        return;
      }
      finishSession(session, {
        status: "runtime_error",
        exitCode,
        signal,
        message: `Process exited with code ${exitCode}${signal ? ` (signal ${signal})` : ""}.`,
      });
    });

    session.killTimer = setTimeout(() => {
      if (session.finished) return;
      session.terminatedReason = `Execution timed out after ${Math.round(
        SESSION_TIMEOUT_MS / 1000
      )} seconds.`;
      child.kill("SIGKILL");
    }, SESSION_TIMEOUT_MS);

    if (typeof input === "string" && input.length) {
      child.stdin.write(input);
    }

    return res.status(201).json({ sessionId, timeoutMs: SESSION_TIMEOUT_MS });
  } catch (err) {
    cleanupTempArtifacts({ tempFile, tempDir });
    return res.status(err.status || 500).json({ error: err.message || "Run failed" });
  }
};

const streamRunSession = (req, res) => {
  const session = runSessions.get(req.params.sessionId);
  if (!session || session.userId !== req.user.id) {
    return res.status(404).json({
      error: "Run session not found (expired or unavailable on this server instance).",
    });
  }

  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");
  res.setHeader("X-Accel-Buffering", "no");
  if (typeof res.flushHeaders === "function") res.flushHeaders();
  res.write(": connected\n\n");

  for (const evt of session.events) {
    sendSse(res, evt.event, evt.data);
  }

  if (session.finished) {
    return res.end();
  }

  session.clients.add(res);
  const heartbeat = setInterval(() => {
    if (!res.writableEnded) {
      res.write(": ping\n\n");
    }
  }, 3000);

  req.on("close", () => {
    clearInterval(heartbeat);
    session.clients.delete(res);
  });
};

const sendRunInput = (req, res) => {
  const session = runSessions.get(req.params.sessionId);
  if (!session || session.userId !== req.user.id) {
    return res.status(404).json({
      error: "Run session not found (expired or unavailable on this server instance).",
    });
  }
  if (session.finished) {
    return res.status(409).json({ error: "Run session already finished" });
  }

  const { input } = req.body;
  if (typeof input !== "string") {
    return res.status(400).json({ error: "Input must be a string" });
  }

  try {
    if (input.length) {
      session.child.stdin.write(input);
    }
    return res.json({ ok: true });
  } catch (err) {
    return res.status(500).json({ error: "Unable to write to stdin" });
  }
};

const stopRunSession = (req, res) => {
  const session = runSessions.get(req.params.sessionId);
  if (!session || session.userId !== req.user.id) {
    return res.status(404).json({
      error: "Run session not found (expired or unavailable on this server instance).",
    });
  }
  if (!session.finished) {
    session.terminatedReason = "Execution stopped by user.";
    session.child.kill("SIGKILL");
  }
  return res.json({ stopped: true });
};

module.exports = {
  runPython,
  startRunSession,
  streamRunSession,
  sendRunInput,
  stopRunSession,
};
